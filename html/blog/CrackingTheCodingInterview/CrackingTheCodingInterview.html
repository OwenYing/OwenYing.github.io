<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="x-ua-compatible" content="ie=edge" />

    <title>CrackingTheCodingInterview</title>

    <link rel="stylesheet" href="../../../css/grid960/master.min.css" />
    <link rel="stylesheet" href="../../../css/styles/default.css">
    <script src="../../../js/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>


</head>
<body>

<div class="container_12" id="top">


    <!--Title-->
    <div class="grid_12 align_center">
        <h4>
            Cracking the Coding Interview
        </h4>
    </div>

    <!--Seperation Line-->
    <hr />


    <!--Grid 1-->
    <div class="grid_4">
        <h3>   Optimize & Solve <small>Sep 19, 2017</small>  </h3>

        <p>
            BUD: <br/>
                &nbsp;&nbsp;&nbsp;Bottleneck, &nbsp; Unnecessary work, &nbsp; Duplicated work.
        </p>
        <p>
            DIY: Do It Yourself
        </p>
        <p>
            Simplify and Generalize
        </p>
        <p>
            Base Case and Build
        </p>
        <p>
            Data Structure Brainstorm
        </p>
        <p>
            <a href="Sep192017_OptimizeAndSolve.html">Read more ...</a>
        </p>
    </div>


    <!--=================================-->
    <div class="grid_4">
        <h3> Best Conceivable Runtime <small>Sep 20, 2017</small>  </h3>

        <p>
            BCR: Best Conceivable Runtime
        </p>
        <p>
            BCR is the fastest an algo can be. For example, compare 2 sorted arrays, you at least scan once, BCR-> O(n)
            BCR can be a goal that you optimize your algo. If your algo reach the BCR, then think about optimize
            space complexity. If both BCR and space O(1), then the algo cannot be optimized anymore.
            Also you can analyze your algo with BCR, if your algo has O(n^2) while BCR O(n), then try to reduce a O(n) to O(1)
            in your algo.
        </p>
        <p>
            BCR is a instructor to let you know how good your algo is.
        </p>

    </div>



    <!--=================================-->
    <div class="grid_4">
        <h3> Arrays and Strings <small>Sep 23, 2017</small>  </h3>

        <p>
            Hashtable: <br/>
            SO useful especially unsorted situation.
            Can be implemented as Array or Array+LinkedList.
        </p>
        <ul>ArrayList in Java
            <li>Default size is 10</li>
            <li>Grow: newSize=oldSize+(oldSize>>1);</li>
            <li>Not synchronized.</li>
        </ul>
        <p>
            StringBuffer: <br/>
            Faster than String.
        </p>

    </div>

    <hr/>

    <!--=================================-->
    <div class="grid_4">
        <h3> Linked Lists <small>Sep 23, 2017</small>  </h3>

        <p>
           Delete node: n.next=n.next.next;
        </p>
        <p>
            Runner Technique: <br/>
            2 pointers, "fast" pointer and "slow" pointer. "fast" pointer might be ahead by a fixed amount.
        </p>
        <p>
            Recursive Problem: <br/>
            A numer of linked list problems rely on recursion. If you are having trouble solving a linked list problem,you should explore if a recursive approach will work.
        </p>

        <ul>LinkedList in Java
            <li>Double-linked list</li>
            <li>Not Synchronized. <br/> List list=Collections.synchronizedList(new LinkedList());</li>
        </ul>

    </div>

    <!--=================================-->
    <div class="grid_4">
        <h3> Stacks and Queues <small>Sep 23, 2017</small>  </h3>

        <p>
            Stacks are often useful in certain recursive problems or Palindrome problems.
        </p>
        <p>
            Queues are often used in breadth-first search(BFS) or in implementing a cache.
        </p>

        <hr/>
        <h3>  Binary Heaps  <small>Sep 24, 2017</small>  </h3>
        <p>
            Feature: Each node is smaller than its children. The root is the minimum element in the tree.
        </p>
        <ul>Two key operations
            <li>Insert:</li>
            Insert the element at the right bottom, then compare with its parent and move the node upper.
            <li>Extract Minimum Element:</li>
            Remove the element in the root, move the last element to the root, bubble down this element if it is bigger than its children.
            If both of its children are smaller than it, swap with the smaller one.
        </ul>

    </div>


    <div class="grid_4">
        <h3>  Binary Tree  <small>Sep 24, 2017</small>  </h3>
<pre><code>
    //In-Order traversal
    void inOrderTraversal(TreeNode node)
    {
        if(node != null)
        {
            inOrderTraversal(node.left);
            visit(node);
            inOrderTraversal(node.right);
        }
    }
    //Pre-Order traversal
    void preOrderTraversal(TreeNode node)
    {
        if(node !=null )
        {
            visit(node);
            preOrderTraversal(node.left);
            preOrderTraversal(node.right);
        }
    }
    //Post-Order traversal
    void postOrderTraversal(TreeNode node)
    {
        if(node !=null )
        {
            postOrderTraversal(node.left);
            postOrderTraversal(node.right);
            visit(node);
        }
    }
</code></pre>
    </div>


    <hr/>
    <div class="grid_4">
        <h3>  Graphs  <small>Sep 25, 2017</small>  </h3>
<pre><code>
    //DFS
    void search(Node root)
    {
        if(root == null) return;
        visit(root);
        root.visited = true;

        for each (Node n in root.adjacent)
        {
            if(n.visited == false)
                search(n);
        }
    }
    //BFS: queue
    void search(Node root)
    {
        Queue queue = new Queue();
        root.marked = true;
        queue.enqueue(root); // Add to the end of the queue

        while(!queue.isEmpty())
        {
            Node r = queue.dequeue(); //Remove from the front of the queue
            visit(r);
            foreach(Node n in r.adjacent)
            {
                if(n.marked == false)
                {
                    n.marked = true;
                    queue.enqueue(n);
                }
            }
        }
    }
    //Bidirectional Search: Find shortest path
    //Running two simultaneous BFS, when their searches collide
    //we have found a path.
</code></pre>
    </div>


    <div class="grid_4">
        <h3> Bit Manipulation <small>Sep 28, 2017</small>  </h3>

        <p>
            Negative Numbers: 1, Operate ~ then + 1  2,Inver the bits until meets 1.
        </p>
        <ul>Shift
            <li>x>>1 , add 0 to the left --Arithmetic shift</li>
            <li>x>>>1, add sign bit to the left --Logical shift</li>
        </ul>
        Bit Manipulation:
<pre><code>//Common Bit Tasks: Getting and Setting
    //1,Get Bit &: shift 1 over by i bits(00010000),then AND
    boolean getBit(int num, int i)
        return ((num & (1 << i)) != 0);

    //2,Set Bit |: shift 1 over by i bits, then OR
    int setBit(int num, int i)
        return num | (1 << i);

    //3,Clear Bit &
    int clearBit(int num, int i)
    {
        int mask = ~(1 << i);
        return num & mask;
    }

    //4,Update Bit
    int updateBit(int num, int i, boolean bitIsOne)
    {
        int value = bitIsOne ? 1:0;
        int mask = ~(1 << i);
        return (num & mask) | (value << i); //Clear. then set
    }


</code></pre>


    </div>






    <!--Footer of the page-->
    <hr />
    <div class="grid_5">
        <small>
            <a href="../../../index.html">Back</a>
        </small>
    </div>
    <div class="grid_2 align_center">
        <small>
            <a href="http://owenying.github.io">Home</a>
        </small>
    </div>
    <div class="grid_5 align_right">
        <small>
            <a href="#top">Top</a>
        </small>
    </div>
    <div class="clear"></div>

</div>
<!-- end .container_12 -->
</body>
</html>